// this file was auto-generated by wrapit v1.3.1-dirty
#include "Wrapper.h"

#include "jlROOT2.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<TTreeReader::Iterator_t> : std::false_type { };
  template<> struct DefaultConstructible<TTreeReader::Iterator_t> : std::false_type { };
}

// Class generating the wrapper for type TTreeReader::Iterator_t
// signature to use in the veto file: TTreeReader::Iterator_t
struct JlTTreeReader_Iterator_t: public Wrapper {

  JlTTreeReader_Iterator_t(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TTreeReader::Iterator_t (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TTreeReader.h:56:10
    jlcxx::TypeWrapper<TTreeReader::Iterator_t>  t = jlModule.add_type<TTreeReader::Iterator_t>("TTreeReader!Iterator_t");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TTreeReader::Iterator_t>>(new jlcxx::TypeWrapper<TTreeReader::Iterator_t>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void TTreeReader::Iterator_t::Iterator_t(TTreeReader &, Long64_t) (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TTreeReader.h:77:7
    t.constructor<TTreeReader &, Long64_t>(/*finalize=*/true);
    module_.set_override_module(jl_base_module);

    DEBUG_MSG("Adding wrapper for bool TTreeReader::Iterator_t::operator==(const TTreeReader::Iterator_t &) (" __HERE__ ")");
    // signature to use in the veto list: bool TTreeReader::Iterator_t::operator==(const TTreeReader::Iterator_t &)
    // defined in /home/pgras/.julia/conda/3/include/TTreeReader.h:81:12
    t.method("==", static_cast<bool (TTreeReader::Iterator_t::*)(const TTreeReader::Iterator_t &)  const>(&TTreeReader::Iterator_t::operator==));

    DEBUG_MSG("Adding wrapper for bool TTreeReader::Iterator_t::operator!=(const TTreeReader::Iterator_t &) (" __HERE__ ")");
    // signature to use in the veto list: bool TTreeReader::Iterator_t::operator!=(const TTreeReader::Iterator_t &)
    // defined in /home/pgras/.julia/conda/3/include/TTreeReader.h:88:12
    t.method("!=", static_cast<bool (TTreeReader::Iterator_t::*)(const TTreeReader::Iterator_t &)  const>(&TTreeReader::Iterator_t::operator!=));

    DEBUG_MSG("Adding wrapper for const Long64_t & TTreeReader::Iterator_t::operator*() (" __HERE__ ")");
    // signature to use in the veto list: const Long64_t & TTreeReader::Iterator_t::operator*()
    // defined in /home/pgras/.julia/conda/3/include/TTreeReader.h:113:23
    t.method("getindex", static_cast<const Long64_t & (TTreeReader::Iterator_t::*)() >(&TTreeReader::Iterator_t::operator*));

    DEBUG_MSG("Adding wrapper for const Long64_t & TTreeReader::Iterator_t::operator*() (" __HERE__ ")");
    // signature to use in the veto list: const Long64_t & TTreeReader::Iterator_t::operator*()
    // defined in /home/pgras/.julia/conda/3/include/TTreeReader.h:124:23
    t.method("getindex", static_cast<const Long64_t & (TTreeReader::Iterator_t::*)()  const>(&TTreeReader::Iterator_t::operator*));

    module_.unset_override_module();
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TTreeReader::Iterator_t>> type_;
};
std::shared_ptr<Wrapper> newJlTTreeReader_Iterator_t(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTTreeReader_Iterator_t(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<ROOT::Internal::TTreeReaderArrayBase> : std::false_type { };
  template<> struct DefaultConstructible<ROOT::Internal::TTreeReaderArrayBase> : std::false_type { };
template<> struct SuperType<ROOT::Internal::TTreeReaderArrayBase> { typedef ROOT::Internal::TTreeReaderValueBase type; };
}

// Class generating the wrapper for type ROOT::Internal::TTreeReaderArrayBase
// signature to use in the veto file: ROOT::Internal::TTreeReaderArrayBase
struct JlROOT_Internal_TTreeReaderArrayBase: public Wrapper {

  JlROOT_Internal_TTreeReaderArrayBase(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type ROOT::Internal::TTreeReaderArrayBase (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:29:10
    jlcxx::TypeWrapper<ROOT::Internal::TTreeReaderArrayBase>  t = jlModule.add_type<ROOT::Internal::TTreeReaderArrayBase>("ROOT!Internal!TTreeReaderArrayBase",
      jlcxx::julia_base_type<ROOT::Internal::TTreeReaderValueBase>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<ROOT::Internal::TTreeReaderArrayBase>>(new jlcxx::TypeWrapper<ROOT::Internal::TTreeReaderArrayBase>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for std::size_t ROOT::Internal::TTreeReaderArrayBase::GetSize() (" __HERE__ ")");
    // signature to use in the veto list: std::size_t ROOT::Internal::TTreeReaderArrayBase::GetSize()
    // defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:35:19
    t.method("GetSize", static_cast<std::size_t (ROOT::Internal::TTreeReaderArrayBase::*)()  const>(&ROOT::Internal::TTreeReaderArrayBase::GetSize));

    DEBUG_MSG("Adding wrapper for Bool_t ROOT::Internal::TTreeReaderArrayBase::IsEmpty() (" __HERE__ ")");
    // signature to use in the veto list: Bool_t ROOT::Internal::TTreeReaderArrayBase::IsEmpty()
    // defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:36:14
    t.method("IsEmpty", static_cast<Bool_t (ROOT::Internal::TTreeReaderArrayBase::*)()  const>(&ROOT::Internal::TTreeReaderArrayBase::IsEmpty));

    DEBUG_MSG("Adding wrapper for ROOT::Internal::TTreeReaderValueBase::EReadStatus ROOT::Internal::TTreeReaderArrayBase::GetReadStatus() (" __HERE__ ")");
    // signature to use in the veto list: ROOT::Internal::TTreeReaderValueBase::EReadStatus ROOT::Internal::TTreeReaderArrayBase::GetReadStatus()
    // defined in /home/pgras/.julia/conda/3/include/TTreeReaderArray.h:38:19
    t.method("GetReadStatus", static_cast<ROOT::Internal::TTreeReaderValueBase::EReadStatus (ROOT::Internal::TTreeReaderArrayBase::*)()  const>(&ROOT::Internal::TTreeReaderArrayBase::GetReadStatus));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<ROOT::Internal::TTreeReaderArrayBase>> type_;
};
std::shared_ptr<Wrapper> newJlROOT_Internal_TTreeReaderArrayBase(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlROOT_Internal_TTreeReaderArrayBase(module));
}
